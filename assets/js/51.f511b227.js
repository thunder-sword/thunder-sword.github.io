(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{446:function(t,a,_){"use strict";_.r(a);var s=_(15),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"_0x0-基本概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_0x0-基本概念"}},[t._v("#")]),t._v(" 0x0.基本概念")]),t._v(" "),_("h2",{attrs:{id:"并发运行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发运行"}},[t._v("#")]),t._v(" 并发运行")]),t._v(" "),_("p",[t._v("单核在一个时间段内间断性地交替运行多个程序。")]),t._v(" "),_("h2",{attrs:{id:"并行运行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并行运行"}},[t._v("#")]),t._v(" 并行运行")]),t._v(" "),_("p",[t._v("多核在同一时间分别运行多个程序。")]),t._v(" "),_("h1",{attrs:{id:"_0x1-前趋图和程序执行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_0x1-前趋图和程序执行"}},[t._v("#")]),t._v(" 0x1.前趋图和程序执行")]),t._v(" "),_("h2",{attrs:{id:"_1-前趋图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-前趋图"}},[t._v("#")]),t._v(" 1.前趋图")]),t._v(" "),_("p",[t._v("前趋图（Precedence Graph），是一个有向无循环图，可记为DAG（Directed Acyclic Graph），它用于描述进程之间执行的先后顺序。")]),t._v(" "),_("p",[t._v("图中每个节点可用来表示一个进程或程序段，节点间的有向边则表示两个节点之间存在的"),_("strong",[t._v("偏序（partial Order）"),_("strong",[t._v("或")]),t._v("前趋关系（Precedence Relation）")]),t._v("。")]),t._v(" "),_("p",[t._v("注意，前趋图不能存在循环，所以b图是不合法的，不能实现：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20211012103402.png",alt:"image-20211011141004503"}})]),t._v(" "),_("h2",{attrs:{id:"_2-程序的顺序执行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-程序的顺序执行"}},[t._v("#")]),t._v(" 2.程序的顺序执行")]),t._v(" "),_("p",[t._v("程序在设计时是不考虑并发状况的。")]),t._v(" "),_("p",[t._v("顺序运行时的三个特征：")]),t._v(" "),_("ol",[_("li",[t._v("顺序性：指处理机严格地按照程序所规定的程序执行，即每一操作必须在下一个操作开始之前结束；")]),t._v(" "),_("li",[t._v("封闭性：指程序在封闭的环境下运行，即程序运行时独占全机资源，资源的状态（除初始状态外）只有本程序才能改变它，程序一旦开始执行，其执行结果不受外界因素影响；")]),t._v(" "),_("li",[t._v("可再现性：指只要程序执行时的环境和初始条件相同，当程序重复执行时，都可以获得相同的结果。")])]),t._v(" "),_("h2",{attrs:{id:"_3-程序并发执行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-程序并发执行"}},[t._v("#")]),t._v(" 3.程序并发执行")]),t._v(" "),_("p",[t._v("顺序执行下系统资源的利用率很低，为此系统映入了多道程序技术，使程序或程序段间能并发执行。")]),t._v(" "),_("p",[t._v("但并不是所有程序都能并发执行。")]),t._v(" "),_("p",[t._v("并发执行时的特征：")]),t._v(" "),_("ol",[_("li",[t._v("间断性。执行具有间断性。")]),t._v(" "),_("li",[t._v("失去封闭性。系统中的各种资源由多个并发执行的程序共享，故失去封闭性。")]),t._v(" "),_("li",[t._v("不可再现性。执行时的环境和初始条件相同，但得到的结果却各不相同。")])]),t._v(" "),_("h1",{attrs:{id:"_0x2-进程的描述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_0x2-进程的描述"}},[t._v("#")]),t._v(" 0x2.进程的描述")]),t._v(" "),_("h2",{attrs:{id:"_1-进程的定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程的定义"}},[t._v("#")]),t._v(" 1.进程的定义")]),t._v(" "),_("p",[t._v("在多道程序环境下，程序的执行属于并发执行，此时它们将失去其封闭性，并具有间断性及不可再现性的特征。这决定了通常的程序是不能参与并发执行的，因为程序执行的结果是不可再现的。这样，程序的运行也就失去了意义。为使程序能并发执行，且为了对并发执行的程序加以描述和控制，人们引入了“"),_("strong",[t._v("进程")]),t._v("”的概念。")]),t._v(" "),_("p",[t._v("曾有许多人从不同的角度对进程下过定义，其中较典型的进程定义有：\n　　(1) 进程是程序的一次执行。\n　　(2) 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。\n　　(3) 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。")]),t._v(" "),_("p",[t._v("所以进程没有特别准确的描述和定义，不同系统下的表现也不一样，只能说大概。")]),t._v(" "),_("h2",{attrs:{id:"_2-进程的特征"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-进程的特征"}},[t._v("#")]),t._v(" 2.进程的特征")]),t._v(" "),_("ol",[_("li",[t._v("结构特征。通常的程序是不能并发执行的。为使程序(含数据)能独立运行，应为之配置一进程控制块，即PCB(Process Control Block)；而由程序段、相关的数据段和PCB三部分便构成了进程实体。在早期的UNIX版本中，把这三部分总称为“进程映像”。")]),t._v(" "),_("li",[t._v("动态性。进程的实质是进程实体的一次执行过程，因此，动态性是进程的最基本的特征。动态性还表现在：“它由创建而产生，由调度而执行，由撤消而消亡”。可见，进程实体有一定的生命期，而程序则只是一组有序指令的集合，并存放于某种介质上，其本身并不具有运动的含义，因而是静态的。")]),t._v(" "),_("li",[t._v("并发性。这是指多个进程实体同存于内存中，且能在一段时间内同时运行。并发性是进程的重要特征，同时也成为OS的重要特征。引入进程的目的也正是为了使其进程实体能和其它进程实体并发执行；而程序(没有建立PCB)是不能并发执行的。")]),t._v(" "),_("li",[t._v("独立性。在传统的OS中，独立性是指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。")]),t._v(" "),_("li",[t._v("异步性。这是指进程按各自独立的、 不可预知的速度向前推进，或说进程实体按异步方式运行。")])]),t._v(" "),_("h2",{attrs:{id:"_3-进程的7种状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-进程的7种状态"}},[t._v("#")]),t._v(" 3.进程的7种状态")]),t._v(" "),_("p",[t._v("3种基本状态：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20211012103403.png",alt:"image-20211011151012369"}})]),t._v(" "),_("p",[t._v("挂起状态：")]),t._v(" "),_("p",[t._v("​    挂起进程在操作系统中可以定义为暂时被换出内存的进程，当条件允许的时候，会被操作系统再次调回内存。 引入挂起状态的原因有：")]),t._v(" "),_("ul",[_("li",[t._v("终端用户的请求。")]),t._v(" "),_("li",[t._v("父进程请求。")]),t._v(" "),_("li",[t._v("负荷调节的需要。")]),t._v(" "),_("li",[t._v("操作系统的需要。")])]),t._v(" "),_("p",[t._v("不同状态下挂起又形成了不同的状态，总的进程转换图如下：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20211012103404.png",alt:"image-20211011151153132"}})]),t._v(" "),_("h2",{attrs:{id:"_4-进程管理中的数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-进程管理中的数据结构"}},[t._v("#")]),t._v(" 4.进程管理中的数据结构")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20211012103405.png",alt:"image-20211011152008138"}})]),t._v(" "),_("p",[t._v("1．进程控制块的作用\nPCB中记录了操作系统所需的、用于描述进程的当前情况以及控制进程运行的全部信息。\n当OS要调度某进程执行时，要从该进程的PCB中查出其现行状态及优先级；在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；\n进程在执行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也都需要访问PCB；当进程由于某种原因而暂停执行时，又须将其断点的处理机环境保存在PCB中。\n在进程的整个生命期中，系统总是通过PCB对进程进行控制的，亦即，系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。所以说，PCB是进程存在的惟一标志。\n因为PCB经常被系统访问，尤其是被运行频率很高的进程及分派程序访问，故PCB应常驻内存。系统将所有的PCB组织成若干个链表(或队列)，存放在操作系统中专门开辟的PCB区内。\n在Linux系统中用task_struct数据结构来描述每个进程的进程控制块，在Windows操作系统中则使用一个执行体进程块(EPROCESS)来表示进程对象的基本属性。")]),t._v(" "),_("p",[t._v("2.进程控制块中的信息")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20211012103406.png",alt:"image-20211011152115796"}})]),t._v(" "),_("p",[t._v("3.进程控制块的组织方式")]),t._v(" "),_("p",[t._v("（1）链接方式：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20211012103407.png",alt:"image-20211011152211244"}})]),t._v(" "),_("p",[t._v("（2）索引方式：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20211012103408.png",alt:"image-20211011152228492"}})])])}),[],!1,null,null,null);a.default=r.exports}}]);