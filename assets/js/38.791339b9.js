(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{458:function(_,a,v){"use strict";v.r(a);var t=v(15),s=Object(t.a)({},(function(){var _=this,a=_.$createElement,v=_._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_0x1-问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0x1-问题"}},[_._v("#")]),_._v(" 0x1.问题")]),_._v(" "),v("p",[_._v("目标函数为一元单值函数𝑓: ℝ→ℝ的最小优化问题。\n利用迭代求解的方式。\n记为一维搜索方法。")]),_._v(" "),v("h1",{attrs:{id:"_0x2-黄金分割法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0x2-黄金分割法"}},[_._v("#")]),_._v(" 0x2.黄金分割法")]),_._v(" "),v("p",[_._v("前提：\n目标函数在[𝑎~0~,𝑏~0~ ]上是==单峰的==，即存在唯一的局部极小点。")]),_._v(" "),v("p",[_._v("总体思路\n利用迭代的方式，不断压缩含解区间，直到满足求解的精度。")]),_._v(" "),v("p",[_._v("黄金分割法𝜌为固定值。\n考虑每次迭代使用不同的参数𝜌，即$𝜌_1,𝜌_2,…, 𝜌_𝑘,…$\n参数满足条件\n$𝜌_{𝑘+1}=\\frac{1−2𝜌_𝑘}{1−𝜌_𝑘 }=1−\\frac{𝜌_𝑘}{1−𝜌_𝑘}$")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20210623093727.png",alt:"image-20210518102220051"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20210623093728.png",alt:"image-20210518102207785"}})]),_._v(" "),v("p",[_._v("计算精度方法：")]),_._v(" "),v("p",[_._v("$\\frac12(b_0-a_0)(1-𝜌)^n \\le \\epsilon$")]),_._v(" "),v("p",[_._v("步骤：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("取a~0~,b~0~区间")])]),_._v(" "),v("li",[v("p",[_._v("按照𝜌分隔，得到a1和b1点")])]),_._v(" "),v("li",[v("p",[_._v("判断a1和b1大小，如果a1较小，说明最小值在(a0,b1)区间，作为(a1,b1)，则原a1作为新的区间的b2，再算出新的a2，继续求解；反之类似，原b1作为新的区间的a2。")]),_._v(" "),v("p",[_._v("不断迭代，达到精度值。。。")])])]),_._v(" "),v("p",[_._v("效果：")]),_._v(" "),v("p",[_._v("总压缩比：")]),_._v(" "),v("p",[_._v("$(1-𝜌)^n$")]),_._v(" "),v("h1",{attrs:{id:"_0x3-斐波那契数列法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0x3-斐波那契数列法"}},[_._v("#")]),_._v(" 0x3.斐波那契数列法")]),_._v(" "),v("p",[_._v("$𝑚𝑖𝑛𝑖𝑚𝑖𝑧𝑒 (1−𝜌_1 )(1−𝜌_2 )…(1−𝜌_𝑁)$")]),_._v(" "),v("p",[_._v("$Subject\\ to\\ 𝜌_{𝑘+1}=1−\\frac{𝜌_𝑘}{1−𝜌_𝑘 },𝑘=1,…,𝑁−1$\n$0≤𝜌_𝑘≤\\frac12,𝑘=1,2,…,𝑁$")]),_._v(" "),v("p",[_._v("具体方法")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("F1 F2 F3 F4 F5 F6 F7 F8\n1  2  3  5  8  13 21 34\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br")])]),v("p",[_._v("$𝜌_1=1−\\frac{𝐹_𝑁}{𝐹_{𝑁+1}}$")]),_._v(" "),v("p",[_._v("$𝜌_2=1−\\frac{𝐹_{𝑁-1}}{𝐹_{𝑁}}$")]),_._v(" "),v("p",[_._v("…")]),_._v(" "),v("p",[_._v("$𝜌_N=1−\\frac{𝐹_1}{𝐹_2}$")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20210623093729.png",alt:"image-20210518102837488"}})]),_._v(" "),v("p",[_._v("其中$1-2𝜌_k=(1-𝜌_k)𝜌_{k+1}$")]),_._v(" "),v("p",[_._v("计算精度方法：")]),_._v(" "),v("p",[_._v("$\\frac12(b_0-a_0)\\frac {F_1}{F_{N+1}} \\le \\epsilon$")]),_._v(" "),v("p",[_._v("步骤：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("取a~0~,b~0~区间")])]),_._v(" "),v("li",[v("p",[_._v("按照𝜌1分隔，每次的𝜌依次取斐波那契数列中值，得到a1和b1点")])]),_._v(" "),v("li",[v("p",[_._v("判断a1和b1大小，如果a1较小，说明最小值在(a0,b1)区间，作为(a1,b1)，则原a1作为新的区间的b2，再算出新的a2，继续求解；反之类似，原b1作为新的区间的a2。")]),_._v(" "),v("p",[_._v("不断迭代，达到精度值。。。")])])]),_._v(" "),v("p",[_._v("效果：")]),_._v(" "),v("p",[_._v("总压缩比为：")]),_._v(" "),v("p",[_._v("$(1−𝜌_1 )(1−𝜌_2 )…(1−𝜌_𝑁)=\\frac1{F_{N+1}}$")]),_._v(" "),v("h1",{attrs:{id:"_0x4-二分法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0x4-二分法"}},[_._v("#")]),_._v(" 0x4.二分法")]),_._v(" "),v("p",[_._v("计算一个点的导数值\n压缩比为1/2, 比斐波那契数列法的压缩比还要高。")]),_._v(" "),v("h1",{attrs:{id:"_0x5-牛顿法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0x5-牛顿法"}},[_._v("#")]),_._v(" 0x5.牛顿法")]),_._v(" "),v("p",[_._v("找二次插值多项式，满足函数值、一阶导和二阶导条件")]),_._v(" "),v("p",[_._v("步骤：")]),_._v(" "),v("p",[_._v("$𝑞(𝑥)=𝑓(𝑥^{(𝑘)} )+𝑓′ (𝑥^{(𝑘)} )(𝑥−𝑥^{(𝑘)} )+1/2 𝑓′′ (𝑥^{(𝑘)} ) (𝑥−𝑥^{(𝑘)} )^2$\n$𝑞^′ (𝑥)=0$")]),_._v(" "),v("p",[_._v("$𝑥^{(𝑘+1)}=𝑥^{(𝑘)}−\\frac{𝑓′ (𝑥^{(𝑘)} )}{𝑓′′ (𝑥^{(𝑘)} ) }$")]),_._v(" "),v("p",[_._v("•上面的牛顿迭代公式，实际上搜索到f′(x)=0的解。")]),_._v(" "),v("p",[_._v("牛顿迭代公式，用于解方程𝑔(𝑥)=0\n$𝑥^{(𝑘+1)}=𝑥^{(𝑘)}−\\frac{g′ (𝑥^{(𝑘)} )}{g′′ (𝑥^{(𝑘)} ) }$")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20210623093730.png",alt:"image-20210518105844665"}})]),_._v(" "),v("p",[_._v("前提：")]),_._v(" "),v("p",[_._v("𝑓′′ (𝑥)>0时，牛顿法运行正常。")]),_._v(" "),v("p",[_._v("问题：")]),_._v(" "),v("ul",[v("li",[_._v("可能收敛到极大点")]),_._v(" "),v("li",[_._v("牛顿法的收敛性和初始值的选取有关，有可能不收敛。")])]),_._v(" "),v("h1",{attrs:{id:"_0x6-割线法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0x6-割线法"}},[_._v("#")]),_._v(" 0x6.割线法")]),_._v(" "),v("p",[_._v("利用割线的斜率代替切线的斜率")]),_._v(" "),v("p",[_._v("步骤：")]),_._v(" "),v("p",[_._v("迭代公式：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20210623093731.png",alt:"image-20210518110529280"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20210623093732.png",alt:"image-20210518110538045"}})]),_._v(" "),v("h1",{attrs:{id:"_0x7-划界法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0x7-划界法"}},[_._v("#")]),_._v(" 0x7.划界法")]),_._v(" "),v("p",[_._v("找到三点𝑎,𝑐,𝑏满足\n𝑓(𝑐)<𝑓(𝑎)\n𝑓(𝑐)<𝑓(𝑏)")]),_._v(" "),v("h1",{attrs:{id:"_0x8-多维优化问题中的一维搜索"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0x8-多维优化问题中的一维搜索"}},[_._v("#")]),_._v(" 0x8.多维优化问题中的一维搜索")]),_._v(" "),v("p",[_._v("$𝑥^{(𝑘+1)}=𝑥^{(𝑘)}+𝑎_𝑘 𝑑^{(𝑘)}\n\\𝜙(𝑎)=𝑓(𝑥^{(𝑘)}+𝑎_𝑘 𝑑^{(𝑘)})\n\\𝜙′ (𝑎)=𝑑^{(𝑘)⊺} 𝛻𝑓(𝑥^{(𝑘)}+𝑎_𝑘 𝑑^{(𝑘)})$")])])}),[],!1,null,null,null);a.default=s.exports}}]);