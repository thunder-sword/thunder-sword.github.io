(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{462:function(t,a,_){"use strict";_.r(a);var s=_(15),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"_0x0-总览"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_0x0-总览"}},[t._v("#")]),t._v(" 0x0.总览")]),t._v(" "),_("p",[t._v("总图：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20210613200300.png",alt:"image-20210428114721014"}})]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20210613200301.png",alt:"image-20210508114105260"}})]),t._v(" "),_("h1",{attrs:{id:"_0x1-模式分解算法的理论基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_0x1-模式分解算法的理论基础"}},[t._v("#")]),t._v(" 0x1.模式分解算法的理论基础")]),t._v(" "),_("ul",[_("li",[t._v("分解的根据：要保证分解后的一组关系能够继续携带完整的实际需求信息")]),t._v(" "),_("li",[t._v("很多时候你都期望你的函数依赖集合能够以尽可能少的依赖数量描述出你的实际需求")]),t._v(" "),_("li",[t._v("因为分解的时候你期望关注一个最少数量的函数依赖的集合，但是它必须能够反映所有需求")])]),t._v(" "),_("h1",{attrs:{id:"_0x2-各个概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_0x2-各个概念"}},[t._v("#")]),t._v(" 0x2.各个概念")]),t._v(" "),_("h2",{attrs:{id:"_1-armstrong公理系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-armstrong公理系统"}},[t._v("#")]),t._v(" 1.Armstrong公理系统")]),t._v(" "),_("h3",{attrs:{id:"（1）定义："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#（1）定义："}},[t._v("#")]),t._v(" （1）定义：")]),t._v(" "),_("p",[t._v("对于满足一组函数依赖 F 的关系模式R <U，F>，其任何一个关系r，若函数依赖X→Y都成立, （即r中任意两元组t，s，若t[X］=s[X］，则t[Y］=s[Y］），则称F逻辑蕴含X →Y")]),t._v(" "),_("h3",{attrs:{id:"（2）推理规则："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#（2）推理规则："}},[t._v("#")]),t._v(" （2）推理规则：")]),t._v(" "),_("p",[t._v("关系模式R <U，F >来说有以下的推理规则：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("==自反律（Reflexivity）==：若Y 属于 X 属于 U，则X →Y为F所蕴含。")]),t._v(" "),_("p",[t._v("证: 设Y 属于 X 属于 U\n对R <U，F> 的任一关系r中的任意两个元组t，s：\n若t[X]=s[X]，由于Y 属于 X，有t[y]=s[y]，\n所以X→Y成立，自反律得证")])]),t._v(" "),_("li",[_("p",[t._v("==增广律（Augmentation）==：若X→Y为F所蕴含，且Z 属于U，则XZ→YZ为F所蕴含。")]),t._v(" "),_("p",[t._v("证：设X→Y为F所蕴含，且Z 属于 U。\n设R<U，F> 的任一关系r中任意的两个元组t，s：\n若t[XZ]=s[XZ]，则有t[X]=s[X]和t[Z]=s[Z]；\n由X→Y，于是有t[Y]=s[Y]，所以t[YZ]=s[YZ]，所以\nXZ→YZ为F所蕴含，增广律得证。")])]),t._v(" "),_("li",[_("p",[t._v("==传递律（Transitivity）==：若X→Y及Y→Z为F所蕴含，则X→Z为F所蕴含。")]),t._v(" "),_("p",[t._v("证：设X→Y及Y→Z为F所蕴含。\n对R<U，F> 的任一关系 r中的任意两个元组 t，s：\n若t[X]=s[X]，由于X→Y，有 t[Y]=s[Y]；\n再由Y→Z，有t[Z]=s[Z]，所以X→Z为F所蕴含，传递\n律得证。")])]),t._v(" "),_("li",[_("p",[t._v("根据A1，A2，A3这三条推理规则可以得到下面三条推理规则：")])]),t._v(" "),_("li",[_("p",[t._v("==合并规则==：由X→Y，X→Z，有X→YZ。（A2， A3）")])]),t._v(" "),_("li",[_("p",[t._v("==伪传递规则==：由X→Y，WY→Z，有XW→Z。（A2， A3）")])]),t._v(" "),_("li",[_("p",[t._v("==分解规则==：由X→Y及 Z属于Y，有X→Z。（A1， A3）")])]),t._v(" "),_("li",[_("p",[t._v("根据合并规则和分解规则，可得==引理6.1==：")]),t._v(" "),_("p",[t._v("$X→A_1 A_2…A_k$成立的充分必要条件是X→A~i~成立（i=1，2，…，k）")])])]),t._v(" "),_("h2",{attrs:{id:"_2-闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-闭包"}},[t._v("#")]),t._v(" 2.闭包")]),t._v(" "),_("h3",{attrs:{id:"（1）f的闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#（1）f的闭包"}},[t._v("#")]),t._v(" （1）F的闭包")]),t._v(" "),_("p",[t._v("在关系模式R<U，F>中为F所逻辑蕴含的函数依赖的全体叫作==F的闭包==，记为F^+^。")]),t._v(" "),_("p",[t._v("例子：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/ithundersword/BlogImages/raw/master/images/blog/PicGo/20210613200302.png",alt:"image-20210428120247543"}})]),t._v(" "),_("p",[t._v("NP完全问题复杂度太高，因此又定义了X关于函数依赖集F的闭包。")]),t._v(" "),_("h3",{attrs:{id:"（2）x关于函数依赖集f的闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#（2）x关于函数依赖集f的闭包"}},[t._v("#")]),t._v(" （2）X关于函数依赖集F的闭包")]),t._v(" "),_("p",[t._v("设F为属性集U上的一组函数依赖，X 属于U， $X_F^+$ ={ A|X→A能由F 根据Armstrong公理导出}， $X_F^+$称为属性集==X关于函数依赖集F的闭包==(即X所能决定的那些属性)")]),t._v(" "),_("h4",{attrs:{id:"用途："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用途："}},[t._v("#")]),t._v(" 用途：")]),t._v(" "),_("p",[t._v("​    将判定X→Y是否能由F根据Armstrong公理导出的问题，转化为求出XF+ 、判定Y是否为XF+的子集的问题\n​    （转化为数据库表中属性的依赖关系）")]),t._v(" "),_("h4",{attrs:{id:"计算算法："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算算法："}},[t._v("#")]),t._v(" 计算算法：")]),t._v(" "),_("p",[t._v("算法6.1  求属性集X（X 属于 U）关于U上的函数依赖集F 的闭包XF+")]),t._v(" "),_("p",[t._v("输入：X，F\t\t输出：XF+\n步骤：\n（1）令X（0）=X，i=0\n（2）求B，这里B = { A |(∃ V)( ∃ W)(V→W∈F∧V 属于 X（i）∧A∈ W)}；\n（3）X（i+1）=B∪X（i）\n（4）判断X（i+1）= X （i）吗?\n（5）若相等或X（i）=U , 则X（i）就是XF+ , 算法终止。\n（6）若否，则 i=i+l，返回第（2）步。")]),t._v(" "),_("p",[t._v("对于算法6.1， 令ai =|X（i）|，{ai }形成一个步长大于1的严格递增的序列，序列的上界是 | U |，因此该算法最多 |U| - |X| 次循环就\n会终止。")]),t._v(" "),_("h4",{attrs:{id:"例子："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#例子："}},[t._v("#")]),t._v(" 例子：")]),t._v(" "),_("p",[t._v("[例6.1]  已知关系模式R<U，F>，其中\nU={A，B，C，D，E}；\nF={AB→C，B→D，C→E，EC→B，AC→B}。\n求（AB）F+ 。\n解  设X（0）=AB；\n(1) X（1）=AB∪CD=ABCD。")]),t._v(" "),_("p",[t._v("(2) X（0）≠ X（1）\nX（2）=X（1）∪BE=ABCDE。\n(3) X（2）=U，算法终止\n（AB）F+ =ABCDE。")]),t._v(" "),_("h2",{attrs:{id:"_3-闭包相关概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-闭包相关概念"}},[t._v("#")]),t._v(" 3.闭包相关概念")]),t._v(" "),_("h3",{attrs:{id:"（1）覆盖"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#（1）覆盖"}},[t._v("#")]),t._v(" （1）覆盖")]),t._v(" "),_("p",[t._v("定义6.14  如果G+=F+，就说函数依赖集==F覆盖G==（F是G的覆盖，或G是F的覆盖），或F与G等价。")]),t._v(" "),_("p",[t._v("引理6.3  F+ = G+ 的==充分必要条件==是F 属于 G+ ，和G 属于 F+\n证:  必要性显然，只证充分性。\n（1）若F属于G+ ，则XF+ 属于 XG++ 。\n（2）任取X→Y∈F+  则有 Y 属于 XF+  属于 XG++ 。\n所以X→Y ∈ (G+）+= G+。即F+ 属于 G+。\n（3）同理可证G+ 属于 F+ ，所以F+ = G+。")]),t._v(" "),_("h3",{attrs:{id:"（2）最小覆盖（不唯一）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#（2）最小覆盖（不唯一）"}},[t._v("#")]),t._v(" （2）最小覆盖（不唯一）")]),t._v(" "),_("h4",{attrs:{id:"定义和限制："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#定义和限制："}},[t._v("#")]),t._v(" 定义和限制：")]),t._v(" "),_("p",[t._v("定义6.15  如果函数依赖集F满足下列条件，则称F为一个==极小函数依赖集==。亦称为==最小依赖集==或==最小覆盖==。\n(1) F中任一函数依赖的右部仅含有一个属性。\n(2) F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价。  "),_("strong",[t._v("(没有多余的函数依赖)")]),t._v("\n(3) F中不存在这样的函数依赖X→A， X有"),_("strong",[t._v("真子集")]),t._v("Z使得F-{X→A}∪{Z→A}与F等价。 "),_("strong",[t._v("(决定因素里没有多余的属性)")])]),t._v(" "),_("p",[t._v("目的："),_("strong",[t._v("用最少的描述反应实际中事物间的关系从而便于分解")])]),t._v(" "),_("h4",{attrs:{id:"定理6-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#定理6-3"}},[t._v("#")]),t._v(" 定理6.3")]),t._v(" "),_("p",[t._v("每一个函数依赖集F均等价于一个极小函数依赖集Fm。此Fm称为F的最小依赖集。\n证明: 构造性证明，找出F的一个最小依赖集。")]),t._v(" "),_("h4",{attrs:{id:"极小化过程："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#极小化过程："}},[t._v("#")]),t._v(" 极小化过程：")]),t._v(" "),_("p",[t._v("(1)逐一检查F中各函数依赖FDi：X→Y，若Y=A1A2 …Ak，k > 2，\n则用 { X→Aj |j=1，2，…， k} 来取代X→Y。（分解右多项）")]),t._v(" "),_("p",[t._v("(2)逐一检查F中各函数依赖FDi：X→A，令G=F-{X→A}，\n若A∈XG+， 则从F中去掉此函数依赖。（依次擦除，看是否能用其他代替）")]),t._v(" "),_("p",[t._v("(3)逐一取出F中各函数依赖FDi：X→A，设X=B1B2…Bm，\n逐一考查Bi （i=l，2，…，m），若A ∈（X-Bi ）F+ ，\n则以X-Bi 取代X。（检查左多项，是否可以减少左多项数目）")]),t._v(" "),_("h4",{attrs:{id:"例子：-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#例子：-2"}},[t._v("#")]),t._v(" 例子：")]),t._v(" "),_("p",[t._v("[例6.2] 关系模式S<U，F>，其中：\nU={ Sno，Sdept，Mname，Cno，Grade }，\nF={ Sno→Sdept，Sdept→Mname，(Sno，Cno)→Grade }\n设F’={Sno→Sdept，Sno→Mname，Sdept→Mname，\n(Sno，Cno)→Grade，(Sno，Sdept)→Sdept}\nF是最小覆盖，而F’不是。\n因为：F ’ - {Sno→Mname}与F ’等价\nF ’ - {(Sno，Sdept)→Sdept}也与F ’等价")]),t._v(" "),_("p",[t._v("[例6.13]   F = {A→B，B→A，B→C，A→C，C→A}\nFm1、Fm2都是F的最小依赖集：\nFm1= {A→B，B→C，C→A}\nFm2= {A→B，B→A，A→C，C→A}\nF的最小依赖集Fm"),_("strong",[t._v("不唯一")]),t._v("\n极小化过程( 定理6.3的证明 )也是检验F是否为极小依赖集的一个算法")])])}),[],!1,null,null,null);a.default=r.exports}}]);